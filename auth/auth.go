// Package auth implements a simple authentication scheme. It checks user credentials, and on successful
// check, it generates an encrypted, time limited token, that can be used for subsequent checks.
//
// For checking credentials it uses external authenticator, passed during initialization.
package auth

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"encoding/binary"
	"errors"
	"time"
)

const (
	defaultTokenValidity = 7776000 // 90 days
	renewThresholdRate   = 0.1
	invalidTokenMessage  = "Invalid token."
)

var (
	// aes key and iv: valid during the time the application is running
	// update now possible only through restarting the app
	// (if want to update during run time, will need to take care about the previously issued keys, too)
	key []byte = make([]byte, aes.BlockSize)
	iv  []byte = make([]byte, aes.BlockSize)

	tokenValidity  time.Duration = defaultTokenValidity * time.Second
	renewThreshold time.Duration = time.Duration(float32(defaultTokenValidity)*renewThresholdRate) * time.Second

	auth Authenticator
)

// Package auth uses implementations of Authenticator to verify the validity of a username password pair.
type Authenticator interface {
	// Returns nil if username and password are valid credentials.
	Authenticate(username, password string) error
}

// Wrapper for standalone function implementations of Authenticator.
type AuthFunc func(string, string) error

// Calls f.
func (f AuthFunc) Authenticate(username, password string) error {
	return f(username, password)
}

// A type that implements Config can be used to pass initialization values to the package.
type Config interface {
	AesKey() []byte     // AES key used for encryption
	AesIv() []byte      // AES iv used for encryption
	TokenValidity() int // Validity duration of the generated authentication tokens in seconds.
}

// Implementations of Token can be used to hold the encrypted authentication token.
type Token interface {
	Value() []byte
}

type token struct {
	user    string // username used during checking the credentials
	created int64  // creation time
	val     []byte // encrypted value
}

func (t *token) Value() []byte {
	if t.val != nil {
		return t.val
	}
	val, err := encrypt(*t)
	if err != nil {
		panic(err)
	}
	t.val = val
	return val
}

func decryptToken(v []byte) (token, error) {
	t := token{val: v}
	b, err := crypt(v)
	if err != nil {
		return t, err
	}
	userPos := len(iv) + 8
	if len(b) < userPos || !bytes.Equal(b[:len(iv)], iv) {
		return t, errors.New(invalidTokenMessage)
	}
	t.created, _ = binary.Varint(b[len(iv):userPos])
	t.user = string(b[userPos:])
	return t, nil
}

func encrypt(t token) ([]byte, error) {
	cap := len(iv) + 8 + len(t.user)
	b := make([]byte, cap, cap)
	copy(b, iv)
	binary.PutVarint(b[len(iv):], t.created)
	copy(b[cap-len(t.user):], t.user)
	return crypt(b)
}

// encryption/decryption with AES CTR
func crypt(in []byte) ([]byte, error) {
	b, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}
	s := cipher.NewCTR(b, iv)
	out := make([]byte, len(in))
	s.XORKeyStream(out, in)
	return out, nil
}

func validate(t token) (token, error) {
	d := time.Now().Sub(time.Unix(t.created, 0))
	if d > tokenValidity {
		return t, errors.New(invalidTokenMessage)
	}
	if d < renewThreshold {
		return t, nil
	}
	t.val = nil
	t.created = time.Now().Unix()
	return t, nil
}

// Checks if the provided username and password are correct. If yes, an authentication
// token is returned, otherwise an error.
func AuthPwd(user, pwd string) (Token, error) {
	var t token
	err := auth.Authenticate(user, pwd)
	if err != nil {
		return nil, err
	}
	t.user = user
	t.created = time.Now().Unix()
	return &t, nil
}

// Validates previously provided tokens if they didn't expire. If not, it
// returns the same token or a new one with extended expiration, so that a
// session doesn't expire due to inactivity shorter than 90% of the token
// validity interval.
func AuthToken(t Token) (Token, error) {
	if t == nil {
		return nil, errors.New(invalidTokenMessage)
	}
	var (
		tc *token
		ok bool
	)
	if tc, ok = t.(*token); !ok {
		return AuthTokenBytes(t.Value())
	}
	tn, err := validate(*tc)
	return &tn, err
}

// The same as AuthToken but expects the byte representation of a token.
func AuthTokenBytes(v []byte) (Token, error) {
	t, err := decryptToken(v)
	if err == nil {
		t, err = validate(t)
	}
	return &t, err
}

// If the token was generated by package auth, GetUser returns the username
// whom the token belongs to. (Even if the token is expired.)
func GetUser(t Token) (string, error) {
	if t == nil {
		return "", errors.New(invalidTokenMessage)
	}
	if tc, ok := t.(*token); ok {
		return tc.user, nil
	}
	tc, err := decryptToken(t.Value())
	return tc.user, err
}

// Initializes auth by setting the key and iv for AES, and setting the token expiration
// interval. It expects an implementation of Authenticator, which will be used to check user
// credentials when AuthPwd is called. The AES key must be set. (The token expiration's
// default is 90 days.)
//
// Initialization must happen before the first call to the Auth* methods. Reinitializing with
// new keys will discard previously generated tokens. One process can use one 'instance' of
// the auth package.
func Init(c Config, a Authenticator) error {
	if a == nil {
		return errors.New("Authenticator must be defined.")
	}
	auth = a
	key = c.AesKey()
	iv = c.AesIv()
	tokenValidity = time.Duration(c.TokenValidity()) * time.Second
	renewThreshold = time.Duration(float64(tokenValidity) * renewThresholdRate)
	return nil
}
